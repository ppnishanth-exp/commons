name: Org-Wide PR Digest (gh search optimized)

on:
  schedule:
    - cron: "*/5 * * * *"   # Every weekday at 9 AM MST
  workflow_dispatch:

jobs:
  digest:
    runs-on: ubuntu-latest

    steps:
      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y jq gh

      - name: Fetch ALL open PRs across org (1 call via gh search)
        id: prs
        env:
          GH_TOKEN: ${{ secrets.ORG_PAT }}
        run: |
          prs=$(gh search prs \
            --owner ppnishanth-exp \
            --state open \
            --json number,title,url,author,createdAt)

          {
            echo "all_prs<<EOF"
            echo "$prs"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Fetch ALL Slack users (1 call)
        id: slack
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        run: |
          slack_users=$(curl -s -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            https://slack.com/api/users.list)

          {
            echo "slack_users<<EOF"
            echo "$slack_users"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Process + Send Slack DMs (Workaround #2)
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        run: |
          prs='${{ steps.prs.outputs.all_prs }}'
          slack='${{ steps.slack.outputs.slack_users }}'

          echo "ðŸ“¥ Building Slack user cache..."
          echo "$slack" | jq -r '.members[] | "\(.name) \(.id)"' > slack_cache.txt
          echo "$slack" | jq -r '.members[] | "\(.profile.display_name) \(.id)"' >> slack_cache.txt
          echo "$slack" | jq -r '.members[] | "\(.profile.real_name) \(.id)"' >> slack_cache.txt

          get_slack_id() {
            grep -i "^$1 " slack_cache.txt | awk '{print $2}' | head -n 1
          }

          get_slack_username() { 
            echo "$1" | sed 's/_comcast//'
          }

          echo "ðŸ“¦ Grouping PRs by author (raw GitHub data)..."
          echo "$prs" | jq '
            map(select(.author != null)) |
            group_by(.author.login) |
            map({key: .[0].author.login, value: .}) |
            from_entries
          ' > grouped.json

          now=$(date +%s)

          for author in $(jq -r 'keys[]' grouped.json); do
            echo "ðŸ” Processing author: $author"

            slack_username=$(get_slack_username "$author")
            slack_id=$(get_slack_id "$author")
            [ -z "$slack_id" ] && continue

            # Workaround #2: jq builds the entire Slack message
            jq -r --arg a "$author" --argjson now "$now" '
              .[$a]
              | sort_by(.createdAt)
              | map(
                  "- *#\(.number)* \(.title) (" +
                  (((($now - (.createdAt | fromdate)) / 86400) | floor) | tostring) +
                  "d)\n  \(.url)"
                )
              | join("\n")
            ' grouped.json > message.txt

            text="*Your Open PRs Across the Organization*\n$(cat message.txt)"

            echo "ðŸ“¨ Sending DM to $author ($slack_id)"
            curl -s -X POST \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              -H "Content-type: application/json" \
              --data "{\"channel\":\"$slack_id\",\"text\":\"$text\"}" \
              https://slack.com/api/chat.postMessage
          done